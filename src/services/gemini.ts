// Hardened Gemini Script Generation with Deterministic JSON Output
import { z } from 'zod';
import { AI } from '../config/ai';
import { track } from './analytics';

/**
 * Zod schema for script validation
 */
const ScriptSegmentSchema = z.object({
  id: z.string(),
  text: z.string(),
  approxSec: z.number(),
  markers: z.array(z.object({
    type: z.enum(['breath', 'pause', 'affirm']),
    t: z.number().optional()
  })).optional()
});

const ScriptSchema = z.object({
  segments: z.array(ScriptSegmentSchema),
  outline: z.string(),
  safetyNotes: z.array(z.string()).optional(),
  version: z.string(),
  hash: z.string()
});

/**
 * Represents a single segment of a generated script.
 */
export type ScriptSegment = z.infer<typeof ScriptSegmentSchema>;

/**
 * Represents the complete plan for a session script generated by Gemini.
 */
export type ScriptPlan = z.infer<typeof ScriptSchema>;

/**
 * Parameters for generating a session script.
 */
export interface GetSessionScriptParams {
  goalId: string;
  egoState: string;
  lengthSec: number;
  locale: string;
  level: number;
  streak: number;
  userPrefs: Record<string, any>;
}

/**
 * System rules for deterministic JSON output
 */
const SYSTEM_RULES = `
You are a hypnotherapy script generator. Output MUST be valid JSON matching this exact schema:

{
  "segments": [
    {
      "id": "intro",
      "text": "Welcome to your transformation session...",
      "approxSec": 15,
      "markers": [{"type": "breath", "t": 10}]
    }
  ],
  "outline": "Brief session description",
  "safetyNotes": ["Safety information"],
  "version": "1.0.0",
  "hash": "unique_hash"
}

CRITICAL RULES:
- Return JSON ONLY. No markdown, no code fences, no commentary.
- Escape all quotes properly in text content.
- Do not include trailing commas.
- Keep each segment text under 500 characters.
- approxSec should be between 10-60 seconds per segment.
- Include 4-8 segments total for a complete session.
- Use hypnotic language patterns: embedded commands, presuppositions, sensory language.
`;

/**
 * Circuit breaker for Gemini API calls
 */
class CircuitBreaker {
  private failureCount = 0;
  private lastFailureTime = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  
  constructor(
    private failureThreshold = 5,
    private timeoutMs = 60000, // 1 minute
  ) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime < this.timeoutMs) {
        throw new Error('Circuit breaker is OPEN - Gemini service temporarily unavailable');
      }
      this.state = 'HALF_OPEN';
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  private onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      track('llm_circuit_open', { failureCount: this.failureCount });
    }
  }
}

const geminiCircuitBreaker = new CircuitBreaker();

/**
 * Token bucket for client-side rate limiting
 */
class TokenBucket {
  private tokens: number;
  private lastRefill: number;

  constructor(
    private capacity: number,
    private refillRate: number // tokens per second
  ) {
    this.tokens = capacity;
    this.lastRefill = Date.now();
  }

  tryConsume(tokens: number = 1): boolean {
    this.refill();
    
    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }
    
    return false;
  }

  private refill() {
    const now = Date.now();
    const elapsed = (now - this.lastRefill) / 1000;
    const tokensToAdd = elapsed * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}

const geminiRateLimit = new TokenBucket(10, 0.1); // 10 requests max, 1 every 10 seconds

/**
 * Defensive JSON extractor - handles prose, code fences, or malformed responses
 */
export function extractJson(raw: string): any {
  if (import.meta.env.DEV) {
    console.log('Gemini: Extracting JSON from raw response length:', raw.length);
  }

  // Try clean JSON parse first
  try { 
    return JSON.parse(raw); 
  } catch {}

  // Try extracting from ```json code fences
  const fenceMatch = raw.match(/```json\s*([\s\S]*?)```/i);
  if (fenceMatch) {
    try { 
      return JSON.parse(fenceMatch[1]); 
    } catch {}
  }

  // Try extracting first balanced JSON object
  const start = raw.indexOf("{");
  const end = raw.lastIndexOf("}");
  if (start !== -1 && end !== -1 && end > start) {
    const slice = raw.slice(start, end + 1);
    try { 
      return JSON.parse(slice); 
    } catch {}
  }

  throw new Error(`Failed to parse JSON. Raw (first 200 chars): ${raw.slice(0, 200)}`);
}

/**
 * Build hardened prompt for deterministic JSON output
 */
function buildHardenedPrompt(params: GetSessionScriptParams): Array<{role: string, content: string}> {
  const userContent = `Generate a hypnotherapy script with these parameters:
Goal: ${params.goalId}
Ego State: ${params.egoState}
Duration: ${params.lengthSec} seconds
User Level: ${params.level}
Session Streak: ${params.streak}
Locale: ${params.locale}

Create a ${Math.ceil(params.lengthSec / 60)}-minute session focusing on ${params.goalId} with ${params.egoState} archetypal energy.
Use progressive relaxation suitable for level ${params.level} users.
Include breathing cues and affirmations appropriate for the goal.`;

  return [
    { role: "system", content: SYSTEM_RULES },
    { role: "user", content: userContent }
  ];
}

/**
 * Fetch with retry and exponential backoff
 */
async function fetchWithRetry(
  url: string, 
  init: RequestInit, 
  opts: { timeoutMs?: number; retries?: number } = {}
): Promise<Response> {
  const { timeoutMs = 20000, retries = 2 } = opts; // Increased from 8000ms
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    
    try {
      const response = await fetch(url, { 
        ...init, 
        signal: controller.signal 
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error: any) {
      clearTimeout(timeoutId);
      
      if (attempt === retries) {
        throw error;
      }
      
      // Exponential backoff with jitter
      const backoff = Math.min(1500 * Math.pow(2, attempt) + Math.random() * 250, 6000);
      if (import.meta.env.DEV) {
        console.log(`Gemini: Retry ${attempt + 1}/${retries} after ${backoff}ms`);
      }
      await new Promise(resolve => setTimeout(resolve, backoff));
    }
  }
  
  throw new Error("Max retries exceeded");
}

/**
 * Generates a session script plan using the Gemini API with hardened JSON parsing.
 */
export async function getSessionScript(params: GetSessionScriptParams): Promise<ScriptPlan> {
  const startTime = Date.now();
  if (import.meta.env.DEV) {
    console.log('Gemini: Generating session script with params:', params);
  }
  track('llm_generation_start', { goalId: params.goalId, egoState: params.egoState });

  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
  const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
  
  if (!supabaseUrl || !supabaseAnonKey) {
    console.warn('Supabase configuration missing. Using mock script.');
    track('supabase_config_missing', { context: 'getSessionScript' });
    return getMockScriptPlan(params);
  }

  if (!geminiRateLimit.tryConsume()) {
    track('llm_rate_limit_exceeded');
    throw new Error('Gemini API rate limit exceeded. Please wait before making another request.');
  }

  try {
    const scriptPlan = await geminiCircuitBreaker.execute(async () => {
      // Build hardened prompt
      const messages = buildHardenedPrompt(params);
      
      // Call via Supabase Edge Function
      const baseUrl = supabaseUrl.startsWith('http') ? supabaseUrl : `https://${supabaseUrl}`;
      
      const response = await fetchWithRetry(
        `${baseUrl}/functions/v1/ai-hypnosis`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${supabaseAnonKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: messages[1].content, // User prompt
            sessionContext: {
              egoState: params.egoState,
              phase: 'script_generation',
              depth: 1,
              breathing: 'rest',
              userProfile: { level: params.level },
              conversationHistory: []
            },
            requestType: 'script_generation',
            systemRules: SYSTEM_RULES
          })
        },
        { timeoutMs: 20000, retries: 2 }
      );

      const data = await response.json();
      const rawResponse = data.response;

      if (!rawResponse) {
        track('llm_no_content', { response: data });
        throw new Error('No script content generated');
      }

      // Use hardened JSON extraction
      let scriptData: any;
      try {
        scriptData = extractJson(rawResponse);
      } catch (parseError: any) {
        track('llm_parse_error', { 
          error: parseError.message, 
          rawResponse: rawResponse.substring(0, 200) 
        });
        throw new Error(`Failed to parse script response: ${parseError.message}. Raw: ${rawResponse.substring(0, 200)}`);
      }

      // Validate with Zod schema
      let scriptPlan: ScriptPlan;
      try {
        scriptPlan = ScriptSchema.parse(scriptData);
      } catch (validationError: any) {
        track('llm_validation_error', { 
          error: validationError.message, 
          scriptData 
        });
        throw new Error(`Script validation failed: ${validationError.message}`);
      }
      
      track('llm_generation_success', { 
        duration: Date.now() - startTime, 
        segments: scriptPlan.segments.length 
      });
      
      return scriptPlan;
    });
    
    return scriptPlan;
  } catch (error: any) {
    track('llm_generation_failure', { error: error.message });
    console.error('Gemini: Script generation failed, falling back to mock:', error);
    return getMockScriptPlan(params);
  }
}

/**
 * Validates and ensures the response matches our expected format
 */
function validateScriptPlan(parsed: any): ScriptPlan {
  return ScriptSchema.parse(parsed);
}

/**
 * Simple hash generation for cache keys
 */
function generateHash(input: string): string {
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash).toString(36);
}

/**
 * Fallback mock script plan that always validates
 */
function getMockScriptPlan(params: GetSessionScriptParams): ScriptPlan {
  const segments: ScriptSegment[] = [
    { 
      id: 'intro', 
      text: `Welcome to your ${params.egoState} transformation session. We'll work on ${params.goalId} together. Find a comfortable position and allow yourself to relax.`, 
      approxSec: 20,
      markers: [{ type: 'breath', t: 15 }]
    },
    { 
      id: 'induction', 
      text: 'Close your eyes gently and take a deep breath in... hold it for a moment... and slowly let it out. With each breath, feel your body becoming more and more relaxed, more and more peaceful.', 
      approxSec: 30,
      markers: [
        { type: 'breath', t: 8 },
        { type: 'pause', t: 18 },
        { type: 'breath', t: 25 }
      ]
    },
    { 
      id: 'deepening', 
      text: 'Now imagine yourself going deeper into this wonderful state of relaxation. Count slowly backwards from 10 to 1, and with each number, feel yourself sinking twice as deep into peace and calm.', 
      approxSec: 45,
      markers: [
        { type: 'pause', t: 20 },
        { type: 'breath', t: 35 }
      ]
    },
    { 
      id: 'transformation', 
      text: `As your ${params.egoState} energy awakens within you, feel the transformation beginning. You are releasing what no longer serves you and embracing your true potential. These positive changes flow through every part of your being.`, 
      approxSec: 50,
      markers: [
        { type: 'affirm', t: 25 },
        { type: 'breath', t: 40 }
      ]
    },
    { 
      id: 'integration', 
      text: 'These powerful changes are becoming part of you now. Feel them integrating into every cell, every thought, every breath. Your transformation is complete and permanent.', 
      approxSec: 35,
      markers: [
        { type: 'pause', t: 15 },
        { type: 'affirm', t: 30 }
      ]
    },
    { 
      id: 'emergence', 
      text: 'Now it\'s time to return, bringing all these positive changes with you. I\'ll count from 1 to 5. On 5, you\'ll open your eyes feeling completely refreshed, alert, and transformed. 1... 2... 3... 4... 5. Eyes open, fully awake.', 
      approxSec: 35,
      markers: [
        { type: 'pause', t: 15 },
        { type: 'breath', t: 25 }
      ]
    }
  ];

  return {
    segments,
    outline: `${params.egoState} transformation session for ${params.goalId} (${Math.ceil(params.lengthSec / 60)} minutes)`,
    safetyNotes: ['Gentle awakening included', 'User can stop at any time', 'This is a mock script for demonstration'],
    version: 'mock-v1',
    hash: generateHash(segments.map(s => s.text).join(''))
  };
}

/**
 * Pre-built script variations to prevent habituation
 */
export const generateScriptVariation = (protocol: ScriptPlan, variationNumber: number = 1): ScriptPlan => {
  const variations = {
    1: { // Original
      inductionPrefix: '',
      deepeningModifier: '',
      suggestionSuffix: ''
    },
    2: { // Variation A
      inductionPrefix: 'Take your time to settle in... ',
      deepeningModifier: 'even more deeply... ',
      suggestionSuffix: '... and these changes happen naturally and easily'
    },
    3: { // Variation B
      inductionPrefix: 'Allow yourself to begin this journey... ',
      deepeningModifier: 'further and further... ',
      suggestionSuffix: '... becoming more true for you each day'
    }
  };

  const variation = variations[variationNumber as keyof typeof variations] || variations[1];

  const modifiedSegments = protocol.segments.map(segment => ({
    ...segment,
    text: segment.id === 'induction' 
      ? `${variation.inductionPrefix}${segment.text}`
      : segment.id === 'deepening'
      ? segment.text.replace(/deeper/gi, `${variation.deepeningModifier}deeper`)
      : segment.id === 'transformation'
      ? `${segment.text}${variation.suggestionSuffix}`
      : segment.text
  }));

  return {
    ...protocol,
    segments: modifiedSegments,
    hash: generateHash(modifiedSegments.map(s => s.text).join(''))
  };
};